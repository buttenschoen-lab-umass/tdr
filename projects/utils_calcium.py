#!/usr/bin/python
# -*- coding: utf-8 -*-
# Author: Andreas Buttenschoen
from __future__ import print_function, division

import os, sys, re
import datetime
import numpy as np
from numba import jit

from tdr.Domain import Interval
from tdr.Boundary import DomainBoundary, Periodic

from de.fp import fp
from ac.gen import CodeGeneratorBackend

class Namespace(dict):
    def __init__(self):
        pass


def _generate_var_string(definition, rvalue=None, prefix=None):
    """
        definition is a dictionary whose keys are the variable names
    """
    rstr = ''
    if prefix is not None:
        rstr += prefix + ' '

    no_vars = len(definition)-1
    for k, var_name in enumerate(definition.values()):
        if k == no_vars:
            if rvalue is not None:
                rstr += '{0} = {1}'.format(var_name, rvalue)
            else:
                rstr += '{0}'.format(var_name)
        else:
            rstr += '{0}, '.format(var_name)

    return rstr


def _generate_st_src(pars):
    vars = pars.vars
    rhs  = pars.rhs

    cg = CodeGeneratorBackend()
    cg.begin(tab=4*" ")
    cg.write('#!/usr/bin/python')
    cg.write('# -*- coding: utf-8 -*-')
    cg.write('# author: Andreas Buttenschoen {0}'.format(datetime.datetime.now().year))
    cg.write('# Do not modify! File autogenerated - by auto driver!')
    cg.write('from __future__ import print_function, division, absolute_import')
    cg.write('import numpy as np')
    cg.write('')

    # write down global variable definitions
    cg.write('def F(x, *args):')
    cg.indent()
    cg.write('# Initialize return value')
    cg.write('y = np.zeros_like(x)')
    cg.write('')

    # put the parameters into the function
    cg.write('# Parameters')
    for par_name, par_value in pars.items():
        cg.write('{0} = {1}'.format(par_name, par_value))
    cg.write('')

    cg.write('# Variables')
    vstr = _generate_var_string(vars, rvalue='x')
    cg.write(vstr)
    cg.write('')

    # generate the nonlinear function
    cg.write('# GTPase dynamics')
    for k, var_name in vars.items():
        #print('k:', k, ' var:', var_name)
        cg.write('y[{0}] = {1}'.format(str(k), rhs[var_name]))

    cg.write('')
    cg.write('return y')
    cg.write('')
    cg.dedent()
    cg.write('')
    return cg.end()


def get_required_symbols(src, default_value=1.):
    # find required variables
    required_vars = []

    # local copy of source
    rhs = src

    while True:
        try:
            # create a local namespace
            ns = Namespace()

            exec(rhs, ns)
        except NameError as e:
            # parse the exception
            m   = re.search('\'(.+?)\'', e.args[0])
            var = m.group(1)

            # we found something missing!
            required_vars.append(var)

            # prepend some value
            rhs = "{0} = {1}".format(var, default_value) + "; " + rhs

        except Exception as e:
            raise e
        else:
            break

    return set(required_vars)


def _generate_rxn(rxn_id, var_name, pars, *args, **kwargs):
    cg = CodeGeneratorBackend()
    cg.begin(tab=4*" ")
    cg.write('#!/usr/bin/python')
    cg.write('# -*- coding: utf-8 -*-')
    cg.write('# author: Andreas Buttenschoen {0}'.format(datetime.datetime.now().year))
    cg.write('# Do not modify! File autogenerated - by auto driver!')
    cg.write('from __future__ import print_function, division, absolute_import')
    cg.write('import numpy as np')
    cg.write('from numba import jit')
    cg.write('')

    # write down global variable definitions
    cg.write('@jit(nopython=True, nogil=True)')
    cg.write('def rxn{0}({1}):'.format(rxn_id, ", ".join(pars.vars.values())))
    cg.indent()

    # load the rhs
    rhs       = pars.rhs[var_name]
    var_names = set(pars.vars.values())

    # Get a list of the required symbols
    req_sym = get_required_symbols(rhs) - var_names

    # for debugging write the known parameters values
    cg.write('# Expression:')
    cg.write('#\t{0}'.format(rhs))
    cg.write('# Known parameters:')
    for par_name, par_value in pars.items():
        # to keep things readable only include required parameters
        if par_name in req_sym:
            cg.write('#\t{0} = {1}'.format(par_name, par_value))

            # let's also try to replace the parameter in rhs
            rhs = re.sub(r"\b%s\b" % par_name, str(par_value), rhs)

    cg.write('return {0}'.format(rhs))
    cg.write('')

    cg.write('')
    cg.dedent()
    cg.write('')
    return cg.end()


def generate_rxn_src(pars, *args, **kwargs):
    srcs = {}

    for var_idx, var_name in pars.vars.items():
        src = _generate_rxn(var_idx, var_name, pars)
        srcs[var_idx] = src

    return srcs


# list of known parameters - behaves like a dictionary
class Parameters(dict):

    __default_values__ = {'Dc' : 0., 'Dh' : 0., 'Du' : 0,
                          's_star' : 1.0, 'a1' : 0.5, 'a2' : 0.5, 'Rs' : 5.0,
                          'K' : 1. / 7, 'K1' : 324. / 7, 'K2' : 1.,
                          'Gamma' : 40. / 7, 'b' : 1. / 9, 'r1' : 0.1,
                          'r2' : 1.6, 'r3' : 4.0, 'L' : 120, 'n' : 7,
                          'qa' : 0.09, 'qr' : 0.01, 'sa' : 1., 'sr' : 0.25,
                          'ma' : 1./8, 'mr' : 0.25 / 8}

    """ K - is the number of equations """
    def __init__(self, vars=None, rhs=None, *args, **kwargs):

        # set parameters to default values
        for par_name, par_value in self.__default_values__.items():
            setattr(self, par_name, par_value)

        # overwrite any parameter values from construction
        for par_name, par_value in kwargs.items():
            setattr(self, par_name, par_value)

        # define what are the variables etc.
        self.vars = vars
        self.rhs  = rhs

    @property
    def trans(self, n = 2):
        """ Assemble diffusion matrix """
        tm = np.zeros((n, n))
        tm[0, 0] = self.Dc
        tm[1, 1] = self.Dh

        if n > 2:
            tm[2, 2] = self.Du

        return tm


    def clear(self):
        return self.__dict__.clear()

    def copy(self):
        return self.__dict__.copy()

    def has_key(self, k):
        return k in self.__dict__

    def update(self, *args, **kwargs):
        return self.__dict__.update(*args, **kwargs)

    def __setitem__(self, key, item):
        self.__dict__[key] = item

    def __getitem__(self, key):
        return self.__dict__[key]

    def __repr__(self):
        return repr(self.__dict__)

    def __len__(self):
        return len(self.__dict__)

    def keys(self):
        return self.__dict__.keys()

    def values(self):
        return self.__dict__.values()

    def items(self):
        return self.__dict__.items()

    def pop(self, *args):
        return self.__dict__.pop(*args)

    def __cmp__(self, dict_):
        return self.__cmp__(self.__dict__, dict_)

    def __contains__(self, item):
        return item in self.__dict__

    def __iter__(self):
        return iter(self.__dict__)

    def __unicode__(self):
        return unicode(repr(self.__dict__))


def check_path(p):
    if not os.path.exists(p):
        os.makedirs(p)


def setup_domain(*args, **kwargs):
    L = kwargs.pop('L')
    n = kwargs.pop('n')
    bd       = DomainBoundary(left=Periodic(), right=Periodic())
    interval = Interval(0, L, n=n, bd=bd)

    return interval


def create_rxn_term(pars, *args, **kwargs):
    # setup reactions
    R = np.empty(len(pars.vars), dtype=object)

    # create a local namespace
    ns = Namespace()

    # generate source code to execute
    srcs = generate_rxn_src(pars)

    for idx, src in srcs.items():
        exec(src, ns)

        # now can put the object into R
        R[idx] = ns['rxn'+str(idx)]

    return R


def compute_st(pars, *args, **kwargs):
    # generate code to execute to solve for st.st.
    src = _generate_st_src(pars)

    # create a local namespace
    ns = Namespace()

    # execute code in src
    exec(src, ns)

    # now compute the st.st.
    fps = fp(ns['F'], None, x_range=[1e-3, 2.5], npts=25, rdecimals=2)

    print('fps = %s.' % fps)

    # extract steady states
    css = fps[0][0]
    hss = fps[0][1]

    return css, hss
